
python schema_discovery.py --provider gpt4o --url 'https://openai.com/api/pricing/' --out price_discovery

py crawl-cat.py -p gpt4o --pymodel schemas/openai_price_discovered_model.py

---
# Pydantic schema generation prompt:

pydantic_model: |
	root: Shadergraph Node Library
	├── Graph nodes (9 categories in total)
	│   │   ├── Sub-category: Adjustment
	│   │   │   ├── Node: Channel Mixer Node; Description: Controls the amount each of the channels of...
	│   │   │   ├── Node: Contrast Node; Description: Adjusts the contrast of...
	│   │   │   └── (... other nodes with descriptions)
	│   │   ├── Sub-category: Blend
	│   │   │   └── Blend Node; Description: Blends the value of...
	│   │   ├── Sub-category: Filter
	│   │   │   └── (... other nodes with descriptions)
	│   │   └── (... other sub-categories, containing nodes with descriptions)
	│   ├── Topic: Channel
	│   │   ├── Node: Append Node; Description: Creates a new vector Out by... 
	│   │   ├── Node: Combine Node; Description: Creates new vectors from... 
	│   │   └── (... other nodes with descriptions)
	│   ├── Topic: Custom Render Texture nodes
	│   │   └── (... other sub-categories OR nodes)
	│   └── (...9 topics in total)
	└── Block nodes

in our documentation crawler we need to set up documentation extraction for Unity ShaderGrpah Nodes:
https://docs.unity3d.com/Packages/com.unity.shadergraph@17.4/manual/Node-Library.html

To that end, we need to provide in #file:config_unity_shadergraph.yaml a correct pydantic model for Crawl4ai to consume .

In the yaml file, In the pydantic_model key I have stored a tree graph of the structure. Please work out a correct Pydantic model that reflects these requrements: 
1. follows the provided structure in pydantic_model key. Replace the structure with the correct pydantic model
2. reflects the Unity ShaderGrpah Nodes pages at https://docs.unity3d.com/Packages/com.unity.shadergraph@17.4/manual/Node-Library.html 
3. is similar to the models in #file:config_openai_fees.yaml 
4. works with multi-page source: the provided URL contains links to sub-pages, that contain either another sub-categories or shadergraph nodes. 
5. each branch should end in one or more nodes!

---
# old guidance + prompt:

def build_schema_prompt(url: str, html_snippet: str) -> str:
    guidance = (
        "Produce a compact JSON Schema (as a single JSON object) that describes the structured data present on the page. "
        "Return only the raw JSON object (no explanation, no markdown or fences). Include a top-level `examples` array with one example instance. "
        "Ensure the schema contains a `models` array describing model entries when present on the page."
    )
    guidance = guidance + " Do NOT wrap the JSON in markdown or code fences. Return the raw JSON object only."
    prompt = (
        f"You are given the HTML content of a web page (URL: {url}).\n"
        "Analyze the content and propose a compact JSON Schema that describes the data a user would want to extract from this page.\n\n"
        f"Guidance: {guidance}\n\n"
        "Page HTML (trimmed):\n"
        f"{html_snippet}\n\n"
        "Return a single JSON object (the JSON Schema). Do not include any explanation."
    )
    return prompt

---
Crawl instruction:

"""From the crawled content, extract all mentioned model names along with their fees for input and output tokens. \nDo not miss any models in the entire content."""

------
Pytonic model request 1:

Analyze the content and propose a compact JSON Schema that describes the data a user would want to extract from this page (fields, nested objects, arrays).

Guidance: Produce a JSON Schema (draft-like) describing the structured information present on the page. Return only the JSON Schema object as JSON (no commentary). Include required fields and types. Prefer simple types (string, number, boolean, array, object). Add a top-level `examples` key with one example instance.

----
# Field glossary (generated by LLM)
# ````json
# [
#   {
#     "name": "title",
#     "description": "The title of the page.",
#     "examples": [
#       "API Pricing"
#     ]
#   },
#   {
#     "name": "models",
#     "description": "List of flagship models with pricing details.",
#     "examples": []
#   },
#   {
#     "name": "name",
#     "description": "The name of the model.",
#     "examples": [
#       "GPT-5"
#     ]
#   },
#   {
#     "name": "description",
#     "description": "A brief description of the model's capabilities.",
#     "examples": [
#       "The best model for coding and agentic tasks across industries"
#     ]
#   },
#   {
#     "name": "pricing",
#     "description": "Pricing details for the model.",
#     "examples": []
#   },
#   {
#     "name": "input",
#     "description": "Pricing for input tokens.",
#     "examples": [
#       "$1.250 / 1M tokens"
#     ]
#   },
#   {
#     "name": "cached_input",
#     "description": "Pricing for cached input tokens.",
#     "examples": [
#       "$0.125 / 1M tokens"
#     ]
#   },
#   {
#     "name": "output",
#     "description": "Pricing for output tokens.",
#     "examples": [
#       ""
#     ]
#   }
# ]
# ````

-- model 2 ---
from pydantic import BaseModel, Field
from typing import Optional, Any
from typing import List

class DiscoveredModel(BaseModel):
    title: Optional[str] = Field(..., description="The main title of the page.", example="API Pricing")
    contactSalesLink: Optional[str] = Field(..., description="URL to contact sales for more information.", example="/contact-sales/")
    pricingDetails: Optional[List[PricingdetailsItem]] = Field(..., description="List of pricing options and descriptions.", example={"name": "Batch API", "description": "Save 50% on inputs and outputs with the Batch API and run tasks asynchronously over 24 hours.", "link": "https://platform.openai.com/docs/guides/batch"})

# Field glossary (generated by LLM)
# ````json
# [
#   {
#     "name": "title",
#     "description": "The main title of the page.",
#     "examples": [
#       "API Pricing"
#     ]
#   },
#   {
#     "name": "contactSalesLink",
#     "description": "URL to contact sales for more information.",
#     "examples": [
#       "/contact-sales/"
#     ]
#   },
#   {
#     "name": "pricingDetails",
#     "description": "List of pricing options and descriptions.",
#     "examples": [
#       {
#         "name": "Batch API",
#         "description": "Save 50% on inputs and outputs with the Batch API and run tasks asynchronously over 24 hours.",
#         "link": "https://platform.openai.com/docs/guides/batch"
#       }
#     ]
#   }
# ]
# ````


---- next steps:

-- Old structure

├── schema_discovery.py 
├── crawl_cat.py
├── save_utils.py
├── requirements.txt
├── .env
├── sources
│   ├── providers.yaml
│   ├── prompt_Unity_Shadergraph_gpt41.md
│   ├── prompt_Unity_Shadergraph_oss.md
│   └── guidance_OpenAI_fees_gpt4o.md
├── schemas
│   ├── openai_price_discovered_model.py
│   └── openai_price_prompt.txt
└── output

-- New structure

├── .env
├── requirements.txt
├── <source_convig_1>.yaml 
├── <source_convig_2>.yaml 
├── providers.yaml
├── crawl_cat2.py
├── save_utils.py
└── output

--

I love the you now set edge cases to fail clearly, keep it that way.

So prompt in this case is the place where we bring together guidance wtih some extra instructions and html, declared as placeholders in it? If this is going to work with the yaml its fine.

1. lets refactor the build_schema_prompt
2. we only pass --source <id> that will get necessary data from sources.yaml, lets not add more attibutts, it  is already pretty complicated. Dont touch other attributes for now, once we get the prompts running we'll clean them up.
3. I've added both guidance and prompt to the #file:sources.yaml , under id:openai_fees_v1

So thats the task - dont go into any extra work, lets only make the guidance and prompt work at this stage


--
Produce a JSON Schema (draft-like) describing the structured information present on the page.
Return only the JSON Schema object as JSON (no commentary). Include required fields and types.
Prefer simple types (string, number, boolean, array, object). Add a top-level `examples` key with one example instance.
--
Produce a compact JSON Schema (as a single JSON object) that describes the structured data present on the page. Requirements:

Include top-level title and description keys summarizing the purpose of the object.
For each property under properties include:
- type (string, integer, number, boolean, array, object)
- description: one concise human-readable sentence describing the field and when it appears
- examples: a short array with 1 example value (for objects/arrays include a representative instance)
If the field is an object, provide its own properties, required, and description keys and include examples for nested fields.
If the field is an array, specify items with a type and an examples array showing an example item.
Set required at the top-level and at nested object levels for fields that are always present. Use optional fields only when truly optional.
Keep the schema compact (avoid overly permissive additionalProperties: true unless necessary).
Add a top-level examples array containing one representative complete instance of the object (matching the schema).
Prefer concrete, narrow types (e.g., 'integer' for counts, 'number' for prices, 'string' for textual labels, 'boolean' for flags).

Important: this page contains pricing and model names. Do NOT omit any pricing or model-related information. Specifically ensure the schema includes a top-level `models` array (or equivalent) describing each model found on the page. For each model entry include at minimum the following fields when present on the page:
- `model_name` (string)
- `input_cost` (number or string, e.g. 0.03)
- `output_cost` (number or string)
- `units` (string, e.g. "USD per 1K tokens")
- `notes` (string, optional: additional tier/availability notes)

Also extract other fee entries (realtime, image generation, responses API, assistants, subscription tiers, priority processing), and include them under explicit properties (e.g. `realtime`, `image_generation`, `responses`, `assistants`, `subscription`) with structured subfields for costs and units.

Glossary requirement: produce a `glossary` object that lists every field name you put in the schema, with a one-line description and one example for each. The glossary must not omit fields that appear on the page.

Return only the raw JSON object (no explanation, no markdown/code fences).

Do NOT wrap the JSON in markdown or code fences (e.g. ```json). Return the raw JSON object only, with no surrounding text or formatting.
--
Prompt and settings to extract model pricing and glossary from pricing pages. Require models array with model_name, input_cost, output_cost, units, notes; require glossary listing all fields

Guidance: `Return a strict JSON array that represents the ShaderGraph structure`.
  The top-level value MUST be a JSON array of topic objects. Each topic object must have:
    - "topic": string
    - "categories": an array of category objects
  Each category object must have:
    - "category": string
    - "nodes": an array of node name strings

Rules:
  - If a topic has zero categories, represent it as a single category with the topic name.
    Example: {"topic": "Channel", "categories": [{"category": "Channel", "nodes": ["Combine Channels", "Split Channels"]}]}
  - Do NOT include any descriptions, explanations, or extra text outside the JSON array.
  - Only return valid JSON (no Markdown, no commentary). 

Example top-level shape:
  [
    {
      "topic": "Artistic",
      "categories": [
        {"category": "Adjustment", "nodes": ["Channel Mixer", "Contrast"]},
        {"category": "Blend", "nodes": ["Blend Node A", "Blend Node B"]}
      ]
    },
    {
      "topic": "Channel",
      "categories": [{"category": "Channel", "nodes": ["Combine Channels", "Split Channels"]}]
    }
  ]

Make the JSON precise: include all topics, categories and node names found on the page in the structure above.
--
You are given the HTML content of a web page (URL: https://openai.com/api/pricing/).
Analyze the content and propose a compact JSON Schema that describes the data a user would want to extract from this page.

Guidance: Produce a compact JSON Schema (as a single JSON object) that describes the structured data present on the page. Return only the raw JSON object (no explanation, no markdown or fences). Include a top-level `examples` array with one example instance. Ensure the schema contains a `models` array describing model entries when present on the page. Do NOT wrap the JSON in markdown or code fences. Return the raw JSON object only.

Page HTML (trimmed):
<html>
<head><title>Pricing | OpenAI</title></head>
<body>
<header><div>
<a href="#main">Skip to main content</a><div><div><div><button>Log in</button></div></div></div>
</div>
<div><div><div><a href="/"></a></div></div></div></header><div>
<div><div><div>
<div>Switch to</div>
<ul>
<li><a href="https://chatgpt.com/?openaicom-did=d0501e70-c58b-47d5-be71-1ac9d6a5d5a4&amp;openaicom_referred=true">ChatGPT<span>(opens in a new window)</span></a></li>
<li><a href="https://sora.com/">Sora<span>(opens in a new window)</span></a></li>
<li><a href="https://platform.openai.com/">API Platform<span>(opens in a new window)</span></a></li>
</ul>
</div></div></div>
<div>
<nav><div><div>
<a href="/"><div><span>Home</span></div></a><ul>
<li><div><a href="/api/">API Platform</a></div></li>
<li><div><a href="/api/pricing/">API Pricing</a></div></li>
<li><div><a href="/agent-platform/">Agents</a></div></li>
<li><div><a href="/codex/">Codex</a></div></li>
<li><div><a href="/open-models/">Open Models</a></div></li>
<li><div><a href="https://community.openai.com/">Community<span>(opens in a new window)</span></a></div></li>
</ul>
</div></div></nav><nav><div><ul>
<li>
<button>Research</button><div>
<div><button><div><span>Back to main menu</span></div></button></div>
<div><ul>
<li><a href="/research/index/">Research Index</a></li>
<li><a href="/research/">Research Overview</a></li>
<li><a href="/residency/">Research Residency</a></li>
<li><span>Latest Advancements</span></li>
<li><a href="/index/sora-2/">Sora 2</a></li>
<li><a href="/index/introducing-gpt-5/">GPT-5</a></li>
<li><a href="/index/introducing-o3-and-o4-mini/">OpenAI o3 and o4-mini</a></li>
<li><a href="/index/introducing-gpt-4-5/">GPT-4.5</a></li>
<li><a href="/o1/">OpenAI o1</a></li>
<li><a href="/index/gpt-4o-system-card/">GPT-4o</a></li>
</ul></div>
</div>
</li>
<li>
<button>Safety</button><div>
<div><button><div><span>Back to main menu</span></div></button></div>
<div><ul>
<li><a href="/safety/">Safety Approach</a></li>
<li><a href="/security-and-privacy/">Security &amp; Privacy</a></li>
</ul></div>
</div>
</li>
<li>
<a href="/business/">For Business</a><div>
<div><button><div><span>Back to main menu</span></div></button></div>
<div><ul>
<li><a href="/business/">Business Overview</a></li>
<li><a href="/startups/">Startups</a></li>
<li><a href="/solutions/">Solutions</a></li>
<li><a href="/business/chatgpt-pricing/">ChatGPT Pricing</a></li>
<li><a href="/api/pricing/">API Pricing</a></li>
<li><a href="/contact-sales/">Contact Sales</a></li>
</ul></div>
</div>
</li>
<li>
<button>For Developers</button><div>
<div><button><div><span>Back to main menu</span></div></button></div>
<div><ul>
<li><a href="/api/">API Platform</a></li>
<li><a href="/api/pricing/">API Pricing</a></li>
<li><a href="/agent-platform/">Agents</a></li>
<li><a href="/codex/">Codex</a></li>
<li><a href="/open-models/">Open Models</a></li>
<li><a href="https://community.openai.com/">Community<span>(opens in a new window)</span></a></li>
</ul></div>
</div>
</li>
<li>
<a href="https://chatgpt.com/overview?openaicom-did=d0501e70-c58b-47d5-be71-1ac9d6a5d5a4&amp;openaicom_referred=true">ChatGPT</a><div>
<div><button><div><span>Back to main menu</span></div></button></div>
<div><ul>
<li><a href="https://chatgpt.com/overview?openaicom-did=d0501e70-c58b-47d5-be71-1ac9d6a5d5a4&amp;openaicom_referred=true">Explore ChatGPT</a></li>
<li><a href="https://chatgpt.com/for-business/team?openaicom-did=d0501e70-c58b-47d5-be71-1ac9d6a5d5a4&amp;openaicom_referred=true">Business</a></li>
<li><a href="https://chatgpt.com/for-business/enterprise?openaicom-did=d0501e70-c58b-47d5-be71-1ac9d6a5d5a4&amp;openaicom_referred=true">Enterprise</a></li>
<li><a href="https://chatgpt.com/for-business/education?openaicom-did=d0501e70-c58b-47d5-be71-1ac9d6a5d5a4&amp;openaicom_referred=true">Education</a></li>
<li><a href="https://chatgpt.com/pricing?openaicom-did=d0501e70-c58b-47d5-be71-1ac9d6a5d5a4&amp;openaicom_referred=true">Pricing</a></li>
<li><a href="https://chatgpt.com/download?openaicom-did=d0501e70-c58b-47d5-be71-1ac9d6a5d5a4&amp;openaicom_referred=true">Download</a></li>
</ul></div>
</div>
</li>
<li>
<button>Sora</button><div>
<div><button><div><span>Back to main menu</span></div></button></div>
<div><ul>
<li><a href="/sora/">Sora Overview</a></li>
<li><a href="/sora/#features">Features</a></li>
<li><a href="/sora/#pricing">Pricing</a></li>
<li><a href="https://help.openai.com/en/articles/9957612-generating-videos-on-sora">Help Center<span>(opens in a new window)</span></a></li>
<li><a href="https://sora.com/">Sora Log in<span>(opens in a new window)</span></a></li>
</ul></div>
</div>
</li>
<li><a href="/stories/">Stories</a></li>
<li>
<button>Company</button><div>
<div><button><div><span>Back to main menu</span></div></button></div>
<div><ul>
<li><a href="/about/">About Us</a></li>
<li><a href="/charter/">Our Charter</a></li>
<li><a href="/careers/">Careers</a></li>
<li><a href="/brand/">Brand Guidelines</a></li>
</ul></div>
</div>
</li>
<li><a href="/news/">News</a></li>
</ul></div>
<div><button>Log in</button></div></nav>
</div>
<div><div>
<main><span>Pricing | OpenAI</span><div>
<div><div><div><div><div>
<h1>API Pricing</h1>
<div><div><a href="/contact-sales/">Contact sales</a></div></div>
</div></div></div></div></div>
<div><div>
<p><span>Pricing reflects standard processing rates. To optimize cost and performance for different use cases, we also offer:</span></p>
<ul>
<li>
<a href="https://platform.openai.com/docs/guides/batch"><b><u><span>Batch API⁠</span></u></b>⁠<span>(opens in a new window)</span></a><span>: Save 50% on inputs and outputs with the Batch API and run tasks asynchronously over 24 hours.</span>
</li>
<li>
<a href="/api-priority-processing/"><b><u><span>Priority processing</span></u></b><b><span>⁠</span></b>⁠</a><span>: offers reliable, high-speed performance with the flexibility to pay-as-you-go.</span>
</li>
</ul>
</div></div>
<section><div><div>
<div><div><div>
<h2>Flagship models</

Return a single JSON object (the JSON Schema). Do not include any explanation.
--
generated by crawl4ai:

from pydantic import BaseModel, Field
from typing import Optional, Any
from typing import List, Optional

class DiscoveredModel_Navigationitem(BaseModel):
    name: Optional[str] = Field(..., description="")
    url: Optional[str] = Field(..., description="")

class DiscoveredModel_Modelsitem(BaseModel):
    name: Optional[str] = Field(..., description="")
    description: Optional[str] = Field(..., description="")

class DiscoveredModel(BaseModel):
    title: Optional[str] = Field(..., description="")
    navigation: Optional[List[DiscoveredModel_Navigationitem]] = Field(..., description="")
    models: Optional[List[DiscoveredModel_Modelsitem]] = Field(..., description="")
---
generated by copilot:

"""Pydantic model tuned for OpenAI pricing page extraction.

This file defines structured types for model pricing entries found on
https://openai.com/api/pricing/. It is written to be compatible with
Pydantic v1 (the project's requirements pin pydantic>=1.10,<3).

Features:
- Nested, explicit types for model pricing entries (input/cached/output/training)
- Validators that parse raw cost strings like "$0.03 / 1K tokens" into numeric
  value and units for easier downstream use.
- Helper `get_json_schema()` that returns a JSON schema dict whether Pydantic
  v1 or v2 is installed (handles both `schema()`/`schema_json()` and
  `model_json_schema()`). This avoids warnings where code expects
  `model_json_schema()`.
"""

from __future__ import annotations

from typing import Optional, Any, List, Dict
import re
from pydantic import BaseModel, Field, validator


_PRICE_RE = re.compile(r"\$?\s*([0-9,.]+)\s*(?:/\s*([^\n]+))?")


class PriceEntry(BaseModel):
	"""Represents a single price string and parsed numeric/unit values.

	Example raw strings found on the page:
	  - "$1.25 / 1M tokens"
	  - "$0.125 / 1M tokens"
	  - "$100.00 / training hour"
	"""

	raw: Optional[str] = Field(None, description="Original raw price string captured from page")
	value: Optional[float] = Field(None, description="Parsed numeric amount (float).")
	unit: Optional[str] = Field(None, description="Unit text (e.g. '1M tokens', '1K calls', 'training hour').")

	@validator("raw", pre=True, always=True)
	def _parse_raw(cls, v, values):
		# if raw is empty, leave value/unit None
		if not v:
			return v
		if isinstance(v, str):
			m = _PRICE_RE.search(v)
			if m:
				num = m.group(1).replace(",", "")
				try:
					values.setdefault("value", float(num))
				except Exception:
					values.setdefault("value", None)
				unit = m.group(2)
				values.setdefault("unit", unit.strip() if unit else None)
		return v


class ModelPricing(BaseModel):
	"""Structured model entry capturing pricing and metadata."""

	model_name: Optional[str] = Field(None, description="Model identifier or display name")
	title: Optional[str] = Field(None, description="Short title or headline for the model")
	description: Optional[str] = Field(None, description="Short description paragraph")
	model_type: Optional[str] = Field(None, description="Category: flagship/realtime/image/etc.")

	input: Optional[PriceEntry] = Field(None, description="Input price entry")
	cached_input: Optional[PriceEntry] = Field(None, description="Cached input price entry")
	output: Optional[PriceEntry] = Field(None, description="Output price entry")
	training: Optional[PriceEntry] = Field(None, description="Training/fine-tuning price, when present")

	notes: Optional[str] = Field(None, description="Any availability/tier/notes text associated with the model")
	api: Optional[str] = Field(None, description="API name or endpoint associated with this model (e.g. 'Realtime', 'Responses')")


class PricingPage(BaseModel):
	"""Top-level representation of the pricing page.

	The page contains many sections; we focus on model listings and common
	API sections. The lists are permissive (Optional[List[...]]) so missing
	sections do not fail parsing.
	"""

	page_title: Optional[str] = Field(None, description="Page title")
	models: Optional[List[ModelPricing]] = Field(None, description="List of model pricing entries")
	realtime: Optional[List[ModelPricing]] = Field(None, description="Realtime API models/prices")
	image_generation: Optional[List[ModelPricing]] = Field(None, description="Image generation models/prices")
	other_sections: Optional[Dict[str, Any]] = Field(None, description="Catch-all for other structured entries (tools, agents, etc.)")

	def get_json_schema(self) -> Dict[str, Any]:
		"""Return a JSON schema dict in a Pydantic-version-agnostic way.

		- Pydantic v2 provides Model.model_json_schema();
		- Pydantic v1 provides Model.schema() / Model.schema_json().

		This helper attempts v2 first, then falls back to v1.
		"""

		# prefer v2 API if available
		try:
			# type: ignore[attr-defined]
			return self.__class__.model_json_schema()
		except Exception:
			pass

		# fallback to pydantic v1 style
		try:
			return self.__class__.schema()
		except Exception:
			# last resort: build a minimal manual schema
			return {"title": self.__class__.__name__}


__all__ = ["PriceEntry", "ModelPricing", "PricingPage"]
----
